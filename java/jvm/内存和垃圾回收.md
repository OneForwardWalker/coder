# JVM内存模型
![](https://pic1.zhimg.com/80/v2-354d31865d1fb3362f5a1ca938f9a770_720w.jpg)
> 堆和方法区是线程共享，程序计数器、虚拟机栈、本地方法栈是线程私有
* 堆
> 几乎存储所有的实例对象
* 方法区
> 存储被虚拟机加载的类信息，静态变量，常量，以及JIT编译后的代码等数据。
* 程序计数栈
> 表示当前线程执行字节码的行号指示器
* 虚拟机栈
> 为jvm执行java方法服务，会存储方法调用的时候的局部变量、操作数栈、动态链接、方法出口等信息
* 本地方法栈
> 为jvm执行native方法服务
> 
# G1垃圾回收
[G1垃圾回收流程](https://www.jianshu.com/p/989429f646af)
> G1垃圾回收器尽量避免了full gc，建立了可预测的停顿模型，是java8后主流的模拟器
## 年轻代GC
> 年轻代GC,会**STW**，只回收Eden和survivor区。

## 并发标记
1. 初始标记阶段 **STW**,会触发一次年轻代GC
2. 根区域扫描，标记survivor直接可达老年代区域的对象
3. 并发标记，会计算每个区域的对象活性(区域中存活对象的比例)
4. 再次标记，**STW**，修正并发标记的结果，采用初始快照法。
5. 独占清理,**STW**，识别可回收的比例并排序，为混合回收做铺垫。
6. 并发清理,清理完全空闲的区域。
## 混合回收
## FULL GC

# G1如何划分堆内存
# 三色标记算法（可达性分析算法的具体实现，CMS和G1垃圾回收期都是使用的三色标记算法）
[reference](https://www.cnblogs.com/chanshuyi/p/head-first-of-triple-color-marking-algorithm.html)
![](https://shuyi-tech-blog.oss-cn-shenzhen.aliyuncs.com/halo_blog_system_file/JVM%20%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F.png)
## 具体算法
根可达算法的实现：  
* 标记-清除  
> 1. 从GCRoots开始使用标记清楚算法实现，整个标记的过程需要**STW**。具体的实现分为两个阶段，从GCRoots节点开始扫描整个引用链，找到所有可达的对象；在清除阶段，扫描整个引用链的不可达对象，然后将垃圾对象清除掉。在CMS回收器出现之前的所有回收器，都是用这种方式实现的，因此GC停顿的时间都比较长。
* 三色标记算法  
> 1. 将所有的对象分为白色、黑色和灰色三种类型。黑色表示从GCRoots开始，已扫描过他全部引用的对象，灰色表示扫描过对象本身，但是还没完全扫描过他全部引用的对象，白色指的是还没扫描过的对象。
> ![](https://shuyi-tech-blog.oss-cn-shenzhen.aliyuncs.com/halo_blog_system_file/16588052452369.jpg)
> 2. 实现根可达算法的时候，将整个过程拆分成了初始标记、并发标记、重新标记、并发清除四个阶段。初始标记指的是扫描GCRoots直接引用的节点，将他们标记为灰色，这个阶段需要**STW**。并发标记阶段，指的是从灰色节点开始，去扫描真个引用链，将他们标记为黑色，这个阶段不需要STW。重新标记指的是校正由于并发标记阶段的错误，这个阶段需要**STW**。并发清除，指的是将已经确定成为垃圾的对象清除掉，这个阶段不需要**STW**。可以看到将最耗时的引用链扫描剥离出来作为并发标记阶段，将其与用户线程并发执行，从而极大降低了GC的时间。
## 错标和漏标
* **多标**是指原来应该回收的对象，被多余的标记为存活的对象，从而导致该垃圾没有被回收。
![](https://shuyi-tech-blog.oss-cn-shenzhen.aliyuncs.com/halo_blog_system_file/16588065077599.jpg)
产生的原因是，被标记为存活的对象，因为引用链断开变成了**浮动垃圾**，多标还不算严重，因为可以在下次GC的时候回收掉
* **漏标**指的是原本应该被标记为存活的对象，被遗漏标记为黑色，从而导致该垃圾对象被错误回收
![](https://shuyi-tech-blog.oss-cn-shenzhen.aliyuncs.com/halo_blog_system_file/16588069763846.jpg)
**重新标记**解决了这个问题，在并发标记后面增加重新标记阶段，只是对于CMS垃圾回收期和G1垃圾回收器来说，他们解决的原理不同。

## 漏标的解决方案
* 漏标产生的充分条件
 1. 有一个黑色对象在自己被标记之后指向了白色对象
 2. 所有的灰色对象在自己引用扫描完成之前删除了对黑色对象的引用  
CMS采用增量更新的方式，G1采用原始快照的方式
* CMS的解决方案
CMS采用增量更新的方式，破坏第一个条件。记录被标记为黑色的对象又指向了白色对象，在后续的重新标记阶段以这个黑色对象为根，对引用进行重新扫描
* G1的解决方案
G1采用的是原始快照的方式，破坏第二个条件。灰色对象在扫描自己完成后删除了对白色对象的引用，在灰色对象消失之前，将灰色对象引用的白色对象记录下来。在重新标记阶段以白色对象为根，对他的引用进行扫描。这样会产生浮动垃圾



