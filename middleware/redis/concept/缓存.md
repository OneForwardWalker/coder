# 缓存

## 引入缓存
![](https://img-blog.csdnimg.cn/img_convert/37e4378d2edcb5e217b00e5f12973efd.png)
## 缓存雪崩
> 1. 大量缓存数据过期
> 2. redis宕机
> 

![](https://img-blog.csdnimg.cn/img_convert/717343a0da7a1b05edab1d1cdf8f28e5.png)
### 策略
* **大量数据同时过期**
1. 均匀设置过期时间
> 给这些数据的过期时间加上一个随机数

2. 互斥锁
> 如果发现访问的数据不在 Redis 里，就加个互斥锁(设置超时时间)，保证同一时间内只有一个请求来构建缓存

3. 双 key 策略
> 我们对缓存数据可以使用两个 key，一个是主 key，会设置过期时间，一个是备 key，不会设置过期.当业务线程访问不到「主 key 」的缓存数据时，就直接返回
> 「备 key 」的缓存数据，然后在更新缓存的时候，同时更新「主 key 」和「备 key 」的数据.
4. 后台更新缓存
> 让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新。  
> 在业务线程发现缓存数据失效后（缓存数据被淘汰），通过消息队列发送一条消息通知后台线程更新缓存。
> 缓存预热。

* **宕机**
1. 服务熔断或请求限流机制（拒绝服务）
2. 构建 Redis 缓存高可靠集群
   1. 主从节点的方式构建 Redis 缓存高可靠集群


## 缓存击穿
> 某个热点数据过期，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题
![](https://img-blog.csdnimg.cn/img_convert/acb5f4e7ef24a524a53c39eb016f63d4.png)

## 策略
1. **互斥锁**方案，**读或更新加锁**，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
2. **不**给热点数据**设置过期时间**，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间

## 缓存穿透
> 当用户访问的数据，既不在缓存中，也不在数据库中
> 
![](https://img-blog.csdnimg.cn/img_convert/b7031182f770a7a5b3c82eaf749f53b0.png)
### 策略
1. 限制恶意请求
2. 缓存空值或者默认值
3. 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在
   * 布隆过滤器由「**初始值都为 0 的位图**数组」和「 **N 个哈希函数**」两部分组成，当我们在**写入数据库数据时**，在布隆过滤器里**做个标记**，
   这样下次查询数据是否在数据库时，只需要查询布隆过滤器，如果查询到数据没有被标记，说明不在数据库中。
      * 布隆过滤器会通过 3 个操作完成标记：    
      第一步，使用 N 个哈希函数分别对数据做哈希计算，得到 **N 个哈希值**；  
      第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到**每个哈希值在位图数组的对应位置**。  
      第三步，将每个哈希值在位图数组的对应位置的**值设置为 1**；  
      * 所以全为1不一定存在，不全为1肯定不存在
      


## 缓存一致性
## 先更新数据库，再更新缓存--写回缓存的没有时序，可能返回旧值
A 请求先将数据库的数据更新为 1，然后在更新缓存前，请求 B 将数据库的数据更新为 2，紧接着也把缓存更新为 2，然后 A 请求更新缓存为 1。
此时，数据库中的数据是 2，而缓存中的数据却是 1，出现了缓存和数据库中的数据不一致的现象
## 先更新缓存，再更新数据库--写回数据库没有时序，可能写旧值
A 请求先将缓存的数据更新为 1，然后在更新数据库前，B 请求来了， 将缓存的数据更新为 2，紧接着把数据库更新为 2，然后 A 请求将数据库的数据更新为 1
## 先更新数据库，再删除缓存，并设置过期时间来兜底
如果存在缓存删除失败的场景，会导致一段时间拿到的数据都是旧的。可以引入消息队列加重试机制，写入数据库成功后，写入消息队列，尽量保证删除缓存成功。
