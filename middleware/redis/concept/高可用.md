# 主从

## 概念
要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，
其他服务器依然可以继续提供服务
![](https://img-blog.csdnimg.cn/img_convert/22c7fe97ce5d3c382b08d83a4d8a5b96.png)
## 服务器之间的数据如何保持一致性-主从复制模式
> 这个模式可以保证多台服务器的数据一致性，且主从服务器之间采用的是「**读写分离**」的方式,**主服务器可以进行读写操作**，当发生写操作时自动将写操作同步给从服务器，
> 而**从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令**.
> 
![](https://img-blog.csdnimg.cn/img_convert/2b7231b6aabb9a9a2e2390ab3a280b2d.png)

## 主从同步的过程
### 第一次同步
* 确定谁是主服务器，或者谁是从服务器呢
> redis5.0之前使用slaveof,后面使用**replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>**
#### 3阶段
![](https://img-blog.csdnimg.cn/img_convert/ea4f7e86baf2435af3999e5cd38b6a26.png)
##### 1. 建立链接、协商同步
> 从服务器发生psync给主，主返回fullresync。做准备工作。

执行了 replicaof 命令后，从服务器就会给主服务器发送 psync 命令，表示要进行数据同步。  
psync 命令包含两个参数，分别是主服务器的 runID 和复制进度 offset。  
runID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当从服务器和主服务器第一次同步时，因为不知道主服务器的 run ID，所以将其设置为 "?"。
offset，表示复制的进度，第一次同步时，其值为 -1。  
主服务器收到 psync 命令后，会用 FULLRESYNC 作为响应命令返回给对方。  
并且这个响应命令会带上两个参数：主服务器的 runID 和主服务器目前的复制进度 offset。从服务器收到响应后，会记录这两个值。  
FULLRESYNC 响应命令的意图是采用全量复制的方式，也就是主服务器会把所有的数据都同步给从服务器。  
所以，第一阶段的工作时为了**全量复制**做准备  
##### 2. 主服务器同步数据给从服务器
> 主生成rdb文件，传输给从，从清空当前数据载入rdb文件  
> 确实的数据，主先写到缓冲区
> 
接着，主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器。  
从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。  
这里有一点要注意，主服务器生成 RDB 这个过程是不会阻塞主线程的，因为 bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，
是异步工作的，这样 Redis 依然可以正常处理命令。  
但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。那么为了保证主从服务器的数据一致性，
主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 **replication buffer** 缓冲区里。    
    主服务器生成 RDB 文件期间；  
    主服务器发送 RDB 文件给从服务器期间；  
    「从服务器」加载 RDB 文件期间  
##### 3. 主服务器发送新写操作命令给从服务器
> 从加载完rdb后，主将replication buffer的数据传送给从，同步完成

在主服务器生成的 RDB 文件发送完，从服务器加载完 RDB 文件后，然后将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，然后「从服务器」重新执行这些操作，至此主从服务器的数据就一致了。  
至此，主从服务器的第一次同步的工作就完成了


---
### 命令传播
> 主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接,主通过这个通道将数据传输给从。
![](https://img-blog.csdnimg.cn/img_convert/03eacec67cc58ff8d5819d0872ddd41e.png)
> 
> 
后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。  
而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。  
上面的这个过程被称为**基于长连接的命令传播**，通过这种方式来保证第一次同步后的主从服务器的数据一致性  


---
### 分摊主服务器的压力
> 从服务器过多会导致主的同步压力变大，从服务器也可以作为从服务器的主.只需要在新的redis进程执行**replicaof xx xx**
>
**主服务器是可以有多个从服务器**的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：  
由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；
传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。  
![](https://img-blog.csdnimg.cn/img_convert/4d850bfe8d712d3d67ff13e59b919452.png)

通过这种方式，主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器。

----
### 增量复制
> 主从网络异常，客户端回读到从旧的数据。网络恢复后。主从服务器会采用增量复制的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。

![](https://img-blog.csdnimg.cn/img_convert/4845008abadaa871613873f5ffdcb542.png)

* 主要有三个步骤：
1. 从服务器在恢复网络后，会发送 **psync** 命令给主服务器，此时的 psync 命令里的 **offset 参数不是 -1**；
2. 主服务器收到该命令后，然后用 **CONTINUE 响应**命令告诉从服务器接下来采用**增量复制的方式同步数据**；
3. 然后主服务将主从服务器断线期间，**所执行的写命令**发送给从服务器，然后从服务器执行这些命令

* 主服务器怎么知道要将哪些增量数据发送给从服务器
> 环形缓冲区，默认1M大小，太小的话会被覆盖
1. repl_backlog_buffer，**是一个「环形」缓冲区**，用于主从服务器断连后，从中找到差异的数据；
2. replication offset，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 
来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。

* repl_backlog_buffer 缓冲区是什么时候写入
  * 主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 repl_backlog_buffer 缓冲区里，因此 这个缓冲区里会保存着最近传播的写命令
  * 网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 
  * master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：
如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用**增量同步**的方式；
相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用**全量同步**的方式
![](https://img-blog.csdnimg.cn/img_convert/2db4831516b9a8b79f833cf0593c1f12.png)


---

# 哨兵
> 主从模式，主节点宕机会导致redis服务不可用（不能写入，也没有人给从同步数据），所以需要哨兵机制  
> Redis 在 2.8 版本以后提供的哨兵（Sentinel）机制，它的作用是实现主从节点故障转移。它会监测主节点是否存活，
> 如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。
哨兵一般是以集群的方式部署，**至少需要 3 个哨兵节点**，哨兵集群主要负责三件事情：**监控、选主、通知**
![](https://img-blog.csdnimg.cn/db568766644a4d10b8a91cdd2f8a4070.png)
[哨兵](https://xiaolincoding.com/redis/cluster/sentinel.html)

## 为什么要有哨兵
> 主从模式下主节点挂掉需要**主从节点故障转移**，它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端
> ![](https://img-blog.csdnimg.cn/db568766644a4d10b8a91cdd2f8a4070.png)
## 哨兵机制是如何工作的
> 哨兵其实是一个**运行在特殊模式下的 Redis 进程**，所以它也**是一个节点**。从“哨兵”这个名字也可以看得出来，它相当于是“观察者节点”，观察的对象是主从节点。
当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些“动作”，来修复异常状态。
**哨兵节点主要负责三件事情：监控、选主、通知**。
![](https://img-blog.csdnimg.cn/775865f6bd894dfba8d373ee54d79af1.png)
## 如何判断主节点真的故障了
> 1. 哨兵会**每隔 1 秒给所有主从节点发送 PING 命令**，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行
> ![](https://img-blog.csdnimg.cn/26f88373d8454682b9e0c1d4fd1611b4.png)  
> 2. 如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「**主观下线**」。这个「规定的时间」是配置项 down-after-milliseconds 参数设定的，单位是毫秒
> 3. **客观下线只适用于主节点**。因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。
所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成哨兵集群（**最少需要三台机器来部署哨兵集群**），通过多个哨兵节点一起判断，就可以就可以**避免单个哨兵因为自身网络状况不好，而误判主节点下线**的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低
>    * 怎么判定主节点为「客观下线」的呢?
>       * 投票，当这个哨兵的赞同票数达到**哨兵配置文件中的 quorum** 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点
>      ![](https://img-blog.csdnimg.cn/13e4361407ba46979e802eaa654dcf67.png)
>       

## 由哪个哨兵进行主从故障转移
> 1. 需要在哨兵集群中选出一个 leeder，让 leeder 来执行主从切换。 选举 leeder 的过程其实是一个投票的过程，在投票开始前，肯定得有个「候选者」
>   * 哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。 举个例子，假设有三个哨兵。当哨兵 B 先判断到主节点「主观下线后」，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他哨兵会根据自己和主节点的网络连接情况，做出赞成投票或者拒绝投票的响应.
>   * 如果产生了多个候选者，其他节点投票选举leader的时候只投一次，最终只有一个胜出。
> 
## 主从故障转移的过程
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E5%93%A8%E5%85%B5/%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png)
> 主从故障转移操作包含以下四个步骤:  
> * 第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。
>   * 挑选出一个状态良好、数据完整的从节点，然后向这个「从节点」发送 **SLAVEOF no one** 命令，将这个「从节点」转换为「主节点」
>     * 先筛选网络状态好的（与主节点的连接状态），接下来要对所有从节点进行三轮考察：优先级、复制进度、ID 号。在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。
>       * 第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前，
          第二轮考察：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。
          第三轮考察：如果优先级和下标都相同，就选择从节点 ID 较小的那个
* 第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；
> 哨兵 leader 向所有从节点（server3和server4）发送 SLAVEOF ，让它们成为新主节点的从节点

* 第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；  
> 通过 Redis 的发布者/订阅者机制来实现。主从切换完成后，哨兵就会向 +switch-master 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了
* 第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点  
> 

## 哨兵集群是如何组成
> 哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的。与redis集群主节点有关系

---

# 集群（多个主从模式）
# 集群不可用：  
> 3个节点的集群，在没有复制模型的情况下，第二个节点失效，hash槽为5501-11000不可用  
redis有16384和hash槽，最多有16384个节点  
crc16产生的hash值有2^16=65536搁置，所以可以有65536个hash槽，但是节点数太多会导致心跳包骤增。  