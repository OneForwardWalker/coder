# redis持久化：

## AOF：采用日志的形式记录每个写操作，追加到AOF文件的末尾
* **流程**
> 注意**只会记录写操作**命令，读操作命令是不会被记录的
![](https://img-blog.csdnimg.cn/img_convert/6f0ab40396b7fc2c15e6f4487d3a0ad7.png)
在 Redis 中 AOF 持久化功能默认是不开启的，需要我们修改 redis.conf 配置文件中的以下参数
![](https://img-blog.csdnimg.cn/img_convert/0e2d081af084c41802c7b5de8aa41bd4.png)
* aof文件的格式--普通的文本格式
![](https://img-blog.csdnimg.cn/img_convert/337021a153944fd0f964ca834e34d0f2.png)
> 1. *3表示命令由几部分组成
> 2. 后面的格式是$加数字（表示后面的命令或者键值占多少字节）开头再跟具体的命令或者键或者值
* **写日志的时机**：先执行命令，在写日志
  * 好处：
    * 避免记录错的命令，不需要额外的命令检查
    * 不会阻塞写操作的进行
  * 缺点：
    * 会丢数据
    * 会阻塞下一个命令
* **风险**：  
  执行命令后宕机，**日志缺失**  
  写日志会**阻塞**下一个操作
* **风险解决**（AOF机制的三种写回策略)  
  always:同步写会，执行完命令就写日志  
  everysec:命令执行完，写AOF内存缓冲区，每隔1s同步到磁盘  
  no:把日志写到AOF内存缓存区，由操作系统决定何时写入磁盘
* **AOF文件越来越大怎么解决**  
  **AOF重写机制**：做命令（过期的命令，无效命令）合并，精简存储空间；不阻塞主线程。需要先根据内存数据生成一份aof文件然后替换掉旧的文件，这里也会
           用到写时复制的技术，避免在fork进程的时候就阻塞主进程  
  * Redis 的重写 AOF 过程是由**后台子进程** bgrewriteaof 来完成的，这么做可以达到两个好处
    * 避免重写的时候阻塞主线程
    * 父子进程由独立的数据副本，不用加锁来保证数据安全。最开始是共享的内存，
    发生写时复制的时候就有了独立的数据副本。
      
  * bgrewriteaof的时候主进程的写操作会同步记录到**aof缓冲区**和**aof重写缓冲区**，避免子进程内存数据和主进程不一致的情况
**图解**
1. fork子进程，没有发生写操作的时候，复制页表，共享物理内存,进程就共享了父进程的物理内存数据了，
这样能够**节约物理内存资源**，页表对应的页表项的属性会标记该物理内存的权限为只读
![](https://img-blog.csdnimg.cn/img_convert/5a1f2a90b5f3821c19bea3b7a5f27fa1.png)
2. 当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发缺页中断，这个缺页中断是由于违反权限导致的，
然后操作系统会在「缺页异常处理函数」里进行物理内存的复制，并重新设置其内存映射关系，将父子进程的内存读写权限设置为可读写，
3. 最后才会对内存进行写操作，这个过程被称为「**写时复制**(Copy On Write)」。时复制顾名思义，在发生写操作的时候，
操作系统才会去复制物理内存，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。
   1. 什么时候会阻塞主进程。
      1. fork子进程复制页表。
      2. 写时复制的时候。
![](https://img-blog.csdnimg.cn/img_convert/d4cfac545377b54dd035c775603b4936.png)

* 优缺点：  
  优点：数据的一致性和完整性更高，秒级的数据丢失 
  缺点：相同的数据集，AOF文件的体积大于RDB文件。数据恢复比较慢
---
## RDB：把内存数据以快照的形式存储到磁盘上，一般用于宕机时的快速恢复
> 这里提一点，Redis 的快照是全量快照，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中

 

* 写日志时机（怎么用）:
  * save:
    * 
  * bgsave:
    * 命令的执行全量快照，会fork一个子进程创建rdb文件，不阻塞主线程；
    * 可以通过配置文件来配置执行bgsave命令的频率
      * 默认具有以下配置
        * save 900 1  
          save 300 10  
          save 60 10000  
          * 含义： 900 秒之内，对数据库进行了至少 1 次修改；  
            300 秒之内，对数据库进行了至少 10 次修改；  
            60 秒之内，对数据库进行了至少 10000 次修改。  
    * 执行时数据也可以修改，此时发生写时复制，使用了copyonwrite技术。
      * 执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，
      因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个
      ![](https://img-blog.csdnimg.cn/img_convert/c34a9d1f58d602ff1fe8601f7270baa7.png)
      * 只有在发生修改内存数据的情况时，物理内存才会被复制一份
      ![](https://img-blog.csdnimg.cn/img_convert/ebd620db8a1af66fbeb8f4d4ef6adc68.png)
      * bgsave 快照过程中，如果主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原本的内存数据，而主线程刚修改的数据，
      是被办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照,**宕机会丢失两次rdb快照之间的数据**
      * 在 Redis 执行 RDB 持久化期间，刚 fork 时，主进程和子进程共享同一物理内存，但是途中主进程处理了写操作，修改了共享内存，于是当前被修改的数据的物理内存就会被复制一份.
      那么极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的 2 倍,针对写操作多的场景，我们要留意下快照过程中内存的变化，防止内存被占满了。

* 文件内容:
  1. 二进制文件
     * 如何加载
       * redis没有提供加载rdb文件的命令，服务器启动自动加载

* 优缺点：  
  1. 优点： 适合大规模的数据恢复  
  2. 缺点：数据不实时

* redis4.0开始**混合持久化**：
1. 开启：
如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：  
aof-use-rdb-preamble yes
2. 内存快照以一定频率执行，两次快照之前，使用AOF记录期间的命令操作。
   1. 当开启了混合持久化时，在 **AOF 重写日志**时，fork 出来的重写子进程会先**将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件**，
   然后**主线程处理的操作命令会被记录在重写缓冲区**里，
   **重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件**，写入完成后通知主进程**将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件**。
3. 文件格式
   AOF 文件的前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据
![](https://img-blog.csdnimg.cn/img_convert/f67379b60d151262753fec3b817b8617.png)
4. 优点： 
   1. 重启 Redis 加载数据的时候，由于**前半部分是 RDB 内容，这样加载的时候速度会很快**
   2. 加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得**数据更少的丢失**

## 持久化如何选择
1. 数据不能丢失（并不能保证完全不丢）：混合模式  
2. 只是缓存，可以容忍数据的丢失：rdb  
3. 使用AOF：优先使用everysec 
