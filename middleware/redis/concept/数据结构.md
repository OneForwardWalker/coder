# Redis数据结构

## Redis为什么那么快

> 内存数据库、核心线程单线程、高效数据结构

## 数据类型与数据结构的对应关系

![](https://img-blog.csdnimg.cn/img_convert/9fa26a74965efbf0f56b707a03bb9b7f.png)
可以看到，Redis 数据类型的底层数据结构随着版本的更新也**有所不同**，比如：

* 在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；
* 在最新的 Redis 代码（还未发布正式版本）中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。

### redis内部的存储结构

![](https://img-blog.csdnimg.cn/img_convert/3c386666e4e7638a07b230ba14b400fe.png)

> 首先是一个指向dict结构的指针，dict结构存储**两个hash表**，hash表存储dictEntry(这个里面存储了key和value)

---

## 底层数据结构

### SDS

> 字符串在 Redis 中是很常用的，虽然redis是C语言实现的，并没有使用c语言的char *存储字符串，而是使用SDS

#### C语言字符串的缺陷

> * 获取字符串长度的**时间复杂度**为 O（N）；
> * 字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此**不能保存二进制数据**；
> * **字符串操作函数不高效且不安全**，比如有缓冲区溢出的风险，有可能会造成程序运行终止；

#### SDS 结构设计

* SDS数据结构
  ![](https://img-blog.csdnimg.cn/img_convert/516738c4058cdf9109e40a7812ef4239.png)

> 1. 存储了字符串长度。（O(1)复杂度获取长度，可以存储二进制数据）
> 2. 分配的空间长度。（防止内存溢出，当判断出缓冲区大小不够用时，
>    Redis 会自动将扩大 SDS 的空间大小（**小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容**）
> 3. sds类型。
> 4. 字节数组。

* 好处

> 1. O(1)复杂度获取长度，安全存储二进制数据
> 2. 防止内存溢出
> 3. 节省内存空间
>    1. SDS有5种类型， sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，
>       区别是**数组长度和分配空间大小**这俩字段用的数据类型，好处是小字符串的话结构头占用的空间也比较小
>    2. 紧凑的内存分配
>
>       1. Redis 在编程上还使用了专门的编译优化来节省内存空间，按照实际占用的字节数进行对齐。定义结构体的时候可以
>          使用struct __attribute__((packed))
>
>       ![](https://img-blog.csdnimg.cn/img_convert/35820959e8cf4376391c427ed7f81495.png)
>
>       ![](https://img-blog.csdnimg.cn/img_convert/47e6c8fbc17fd6c89bdfcb5eedaaacff.png)

---

### 双向链表--只有list类型用到了

> Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。

* listNode

> 保存前后继和节点的值

```C
typedef struct listNode {
    //前置节点
    struct listNode *prev;
    //后置节点
    struct listNode *next;
    //节点的值
    void *value;
} listNode;
```

* list
> Redis 在 listNode 结构体基础上又封装了 list 这个数据结构  .
> list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数
```C
typedef struct list {
    //链表头节点
    listNode *head;
    //链表尾节点
    listNode *tail;
    //节点值复制函数
    void *(*dup)(void *ptr);
    //节点值释放函数
    void (*free)(void *ptr);
    //节点值比较函数
    int (*match)(void *ptr, void *key);
    //链表节点数量
    unsigned long len;
} list;
```

* list的优缺点
  * 优点：
    * 获取头尾节点和长度的时间复杂度为O(1).
    * 链表节点可以保存各种不同类型的值，跟dup free match有关
  * 缺点：
    * 节点不连续，无法很好利用 CPU 缓存
    * 保存一个链表节点的值都需要一个链表节点结构头的分配，内存开销较大

### 压缩列表--Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构
> 1. 压缩列表的最大特点，就是它被设计成一种**内存紧凑型**的数据结构，占用一块连续的内存空间，
> 2. 不仅**可以利用 CPU 缓存**，而且会**针对不同长度的数据，进行相应编码**，这种方法可以有效地节省内存开销.
> 3. 缺陷：
>    1. 不能保存过多的元素，否则查询效率就会降低（需要顺序遍历）。
>    2. 新增修改需要移动元素，可能会导致连锁更新
>       1. 压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降。

* 压缩列表结构设计
> 由连续内存块组成的顺序型数据结构,类似于数组  
![](https://img-blog.csdnimg.cn/img_convert/ab0b44f557f8b5bc7acb3a53d43ebfcb.png)  
>压缩列表在表头有三个字段：  
  1. zlbytes，整个压缩列表占用字节数；
  2. zltail，压缩列表尾的偏移量；
  3. zllen，压缩列表节点数量；
  4. zlend，标记压缩列表的结束点，**固定值** 0xFF（十进制255）。

压缩链表的Entry设计：
![](https://img-blog.csdnimg.cn/img_convert/a3b1f6235cf0587115b21312fe60289c.png)


> 在压缩列表中，如果我们要**查找定位第一个元素和最后一个元素**，可以通过表头三个字段的长度直接定位，**复杂度是 O(1)**。  
> 查找其他元素时，就没有这么高效了，只能逐个查找，此时的**复杂度就是 O(N)** 了，因此**压缩列表不适合保存过多的元素**

### hash表
> 哈希表是一种保存键值对（key-value）的数据结构。优点在于，它能以 **O(1) 的复杂度快速查询数据**。
> 存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么**哈希冲突**的可能性也会越高。
> Redis 采用了**链式哈希**来解决哈希冲突。在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。

#### 结构设计、链式Hash、rehash
> 类似于数组加链表的结构，数组每个元素都是一个hash桶，桶中的元素的hash值是一样的
![](https://img-blog.csdnimg.cn/img_convert/dc495ffeaa3c3d8cb2e12129b3423118.png)

##### 缺点:
> 是随着元素的个数增加，链表越来越长，时间复杂度会越来越高。所以会有rehash
##### 渐进式rehash
> 1. 为了避免 rehash 在数据迁移过程中，因拷贝数据的耗时，影响 Redis 性能的情况，所以 Redis 采用了渐进式 rehash，
也就是将数据的迁移的工作**不再是一次性迁移完成，而是分多次迁移**
> 2. 步骤（很巧妙）：在rehash的过程中，对老的hash结构进行的增删改查除了在老表完成，还会迁移到新表（初始化后），随着处理客户端发起的哈希表操作请求数量越多，
> 最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。新增只会在新表增加，访问到的旧表的元素会移动到新表，所以旧表最终会变为一个空表。
##### 触发条件
rehash 的触发条件跟**负载因子**有关系：
1. 当负载因子**大于等于 1** ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是**没有执行RDB 快照或没有进行 AOF 重写**的时候，
就会进行 rehash 操作。
2. 当负载因子**大于等于 5** 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会**强制进行 rehash 操作**。

### 整数集合--只有set用到了
> 整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现
* 整数集合结构设计
> 指定了编码方式和元素的个数，元素的数据类型也是可以动态变化的。
```C
typedef struct intset {
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组
    int8_t contents[];
} intset;
```
* 整数集合的升级操作--尽可能的节省内存（很多数据类型都是为了节省内存），不支持降级操作
> 新加入的元素当前数据类型不能存储，就升级（尽可能节省内存）

例子：
假设有一个整数集合里有 3 个类型为 int16_t 的元素。
![](https://img-blog.csdnimg.cn/img_convert/5dbdfa7cfbdd1d12a4d9458c6c90d472.png)
现在，往这个整数集合中加入一个新元素 65535，这个新元素需要用 int32_t 类型来保存，所以整数集合要进行升级操作，首先需要为 contents 数组扩容，
在原本空间的大小之上再扩容多 80 位（4x32-3x16=80），这样就能保存下 4 个类型为 int32_t 的元素
![](https://img-blog.csdnimg.cn/img_convert/e2e3e19fc934e70563fbdfde2af39a2b.png)
扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变，整个转换过程如下
![](https://img-blog.csdnimg.cn/img_convert/e84b052381e240eeb8cc97d6b729968b.png)

### 跳表--在原来有序链表的基础上，实现了一层多层的有序链表
Redis **只有在 Zset 对象的底层实现用到了跳表**，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。
Zset 对象是唯一一个同时使用了两个数据结构来实现的 Redis 对象，这两个数据结构**一个是跳表，一个是哈希表（哪里用的hash表）**。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。
#### 跳表的结构设计
链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N)，于是就出现了跳表。
跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表，这样的好处是**能快读定位数据**。
例子,三层的跳表：
![](https://img-blog.csdnimg.cn/img_convert/2ae0ed790c7e7403f215acb2bd82e884.png)
* 跳表节点的数据结构
1. zskiplistNode:
> 排位怎么计算，计算某个节点排位的时候，从头节点点到该结点的查询路径上，将**沿途访问过的所有层的跨度累加起来，得到的结果就是目标节点在跳表中的排位**
```C
typedef struct zskiplistNode {
    //Zset 对象的元素值
    sds ele;
    //元素权重值
    double score;
    //后向指针
    struct zskiplistNode *backward;
  
    //节点的level数组，保存每层上的前向指针和跨度
    struct zskiplistLevel {
        // 这里也会有后向指针的信息
        struct zskiplistNode *forward;
        // 跨度实际上是为了计算这个节点在跳表中的排位
        unsigned long span;
    } level[];
} zskiplistNode;
```
* 跳表的数据结构
> **记录了头尾指针**--便于在O(1)时间复杂度内访问跳表的头节点和尾节点  
> **跳表的长度**--便于在O(1)时间复杂度获取跳表节点的数量
> **层级**--便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量
```C
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
```
#### 跳表节点查询过程
* 过程
> 查找一个跳表节点的过程时，跳表会从**头节点的最高层**开始，逐一遍历每一层。在**遍历某一层的跳表节点**时，
> 会用跳表节点中的 SDS 类型的**元素和元素的权重**来进行判断，共有两个判断条件：  
  1. 如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。
  2. 如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。
> **如果上面两个条件都不满足，或者下一个节点为空**时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。
举例：
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png)

如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：
  1. 先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个**节点的权重比要查找节点的小，所以要访问该层上的下一个节点**；
  2. 但是该层的下一个节点是空节点（ leve[2]指向的是**空节点**），于是就会跳到「元素：abc，权重：3」节点的**下一层去**找，也就是 leve[1];
  3. 「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。
虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；
  4. 「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。
#### 跳表节点层数设置--
1. 跳表的相邻两层的节点数量的比例会影响跳表的查询性能

举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个，时间复杂度退化到O(N).
![](https://img-blog.csdnimg.cn/img_convert/2802786ab4f52c1e248904e5cef33a74.png)
2. **跳表的相邻两层的节点数量最理想的比例是 2:1**，查找复杂度可以降低到 O(logN)。
3. 那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？
      1. 如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销
      2. 跳表在创建节点的时候，**随机生成每个节点的层数**，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况
         1. 具体的做法是，跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数**小于 0.25（相当于概率 25%）**，那么层数就增加 1 层
         (并一定是直接将总的层数增加一层，而是逐渐向上，概率越来越小，直到概率大于75%的时候就是这个节点的维护的跳表的层数)， 然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数。
          这样的做法，相当于每增加一层的概率不超过 25%，**层数越高，概率越低**，**层高最大限制是 64**

### quicklist--压缩链表和双向链表的混合体
> redis3.0之前，**List 对象**的底层数据结构是**双向链表或者压缩列表**，后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。  
> 其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 **quicklist 就是一个链表**，而**链表中的每个元素又是一个压缩列表**  
> 
在前面讲压缩列表的时候，我也提到了**压缩列表的不足**，虽然压缩列表是通过**紧凑型的内存布局**节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，
压缩列表会有「**连锁更新**」的风险，一旦发生，会造成性能下降
**_quicklist 解决办法**，通过**控制每个链表节点中的压缩列表的大小或者元素个数**，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。

#### 结构设计
* quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode
> 存储了头尾指针，总元素个数和quicklistNode的个数

**quicklist：**
```C
typedef struct quicklist {
    //quicklist的链表头
    quicklistNode *head;      //quicklist的链表头
    //quicklist的链表头
    quicklistNode *tail; 
    //所有压缩列表中的总元素个数
    unsigned long count;
    //quicklistNodes的个数
    unsigned long len;       
    ...
} quicklist;
```
**quicklistNode：**
> 记录节点的前后继，以及压缩列表的信息（压缩列表的字节大小和元素个数）
```C
typedef struct quicklistNode {
    //前一个quicklistNode
    struct quicklistNode *prev;     //前一个quicklistNode
    //下一个quicklistNode
    struct quicklistNode *next;     //后一个quicklistNode
    //quicklistNode指向的压缩列表
    unsigned char *zl;              
    //压缩列表的的字节大小
    unsigned int sz;                
    //压缩列表的元素个数
    unsigned int count : 16;        //ziplist中的元素个数 
    ....
} quicklistNode;
```
可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样**每个 quicklistNode 形成了一个双向链表**。
但是**链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表**，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl
![](https://img-blog.csdnimg.cn/img_convert/f46cbe347f65ded522f1cc3fd8dba549.png)
在向 quicklist **添加一个元素**的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，
如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。
quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来**规避潜在的连锁更新的风险**，但是这并没有完全解决连锁更新的问题

### listpack--代替压缩链表
**quicklist** 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是**并没有完全解决连锁更新的问题**
因为 **quicklistNode 还是用了压缩列表**来保存元素，**压缩列表连锁更新的问题，来源于它的结构设计**，所以要想彻底解决这个问题，需要设计一个新的数据结构。

* listpack
Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点**不再包含前一个节点的长度**了，压缩列表每个节点正因为需要保存前一个节点的长度字段
，就会有连锁更新的隐患
1. listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。
![](https://img-blog.csdnimg.cn/img_convert/4d2dc376b5fd68dae70d9284ae82b73a.png)
2. 每个 listpack 节点结构如下:
![](https://img-blog.csdnimg.cn/img_convert/c5fb0a602d4caaca37ff0357f05b0abf.png)
listpack **没有压缩列表中记录前一个节点长度的字段**了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，
不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题
> 压缩链表直接记录了列表尾的偏移量，所以尾结点存储前一个节点的偏移量就可以做到遍历。  
> listpack记录的是当前节点的长度和编码方式，新加入节点不会影响其他节点。