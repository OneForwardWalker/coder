# 锁

## 有哪些锁
> 全局锁、表锁、行锁
![](https://img-blog.csdnimg.cn/1e37f6994ef44714aba03b8046b1ace2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70)
# 全局锁
> 会导致整个数据库无法做更新操作，阻塞业务，一般应用在全库做逻辑备份的场景。  
> 可以使用可重复读的隔离级别，利用mvcc完成备份，期间数据库还可以接受更新
# 表级锁
## 表锁
* 对表加锁
  * 读锁
    * lock tables t_student read;
  * 写锁
    * lock tables t_stuent write;
  * 释放锁
    * unlock tables
## 元数据锁MDL
> 不需要显示的使用，在对数据表进行CRUD操作的时候，会加MDL读锁；对一张表结构做结构变更的时候回家MDL写锁  
> MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更  
* 释放
> 事务提交才会释放，并且写锁的优先级大于读锁；所以存在一种场景，线程A 启动事务，但是一直不提交，线程B启动事务获取MDL写锁被阻塞，后续的线程都会等待MDL写锁而被阻塞
## 意向锁
> **意向锁的目的是为了快速判断表里是否有记录被加锁**

* select对记录加共享锁和独占锁
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;
//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;

## AUTO-INC锁
> 锁是一个事务提交后才会释放，声明了AUTO-INC的表，在插入数据的时候，会加一个表级的AUTO-INC锁，插入结束后锁就释放了。  
> musql5.1.22版本开始，innodb实现了一种轻量级锁来实现自增，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁（主从复制的场景下是不安全的）。

# 行锁
> 行级锁的类型主要有三类：
1. Record Lock，记录锁，也就是仅仅把一条记录锁上；
2. Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
3. Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
## 记录锁
## 间隙锁
## next-key

# mysql是怎么加锁的
> 加锁的基本单位是next-key lock，它是由记录锁和间隙锁组成  
> 对记录加锁时，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间

以下面这个表来进行实验说明
![](https://img-blog.csdnimg.cn/img_convert/954708d2f29c2a619e861e57cdf74c11.png)
## 唯一索引等值查询
当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」。
![](https://img-blog.csdnimg.cn/img_convert/2a944fb385d1de277dbfdc78102f36ba.png)
当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」。
![](https://img-blog.csdnimg.cn/img_convert/d82332993969a223fa3433eaf5185134.png)
## 唯一索引范围查询
* select * from t_test where id=8 for update;
最开始要找的第一行是 id = 8，因此 next-key lock(4,8]，但是由于 id 是唯一索引，且该记录是存在的，因此会退化成记录锁，也就是只会对 id = 8 这一行加锁
* select * from t_test where id>=8 and id<9 for update;
范围查找，就会继续往后找存在的记录，也就是会找到 id = 16 这一行停下来，然后加 next-key lock (8, 16]，但由于 id = 16 不满足 id < 9，所以会退化成间隙锁，加锁范围变为 (8, 16)
![](https://img-blog.csdnimg.cn/img_convert/c12bdb8af1972d5f287978b489a83304.png)

## 非唯一索引等值查询
* 当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。
![](https://img-blog.csdnimg.cn/img_convert/be6818bd1fd22c4e790b989bde11e6b1.png)
会话 1 加锁变化过程如下：
1. 先会对普通索引 b 加上 next-key lock，范围是(4,8];
2. 然后因为是非唯一索引，且查询的记录是存在的，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止，因此间隙锁的范围是(8,16)。
* 当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/%E6%A1%88%E4%BE%8B5.drawio.png)
会话 1 加锁变化过程如下：
1. 先会对普通索引 b 加上 next-key lock，范围是(8,16];
2. 但是由于查询的记录是不存在的，所以不会再额外加个间隙锁，但是 next-key lock 会退化为间隙锁，最终加锁范围是 (8,16)。

## 非唯一索引范围查询
> 非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于普通索引范围查询，next-key lock 不会退化为间隙锁和记录锁

![](https://img-blog.csdnimg.cn/img_convert/ac6c09c4011259d3397e62e52a37d384.png)
会话 1 加锁变化过程如下：
1. 最开始要找的第一行是 b = 8，因此 next-key lock(4,8]，但是由于 b 不是唯一索引，并不会退化成记录锁。
2. 但是由于是范围查找，就会继续往后找存在的记录，也就是会找到 b = 16 这一行停下来，然后加 next-key lock (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁

# 总结
* 唯一索引等值查询：
1. 当查询的记录是存在的，next-key lock 会退化成「记录锁」。
2. 当查询的记录是不存在的，next-key lock 会退化成「间隙锁」。
* 非唯一索引等值查询：
1. 当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。
2. 当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。
* 非唯一索引和主键索引的范围查询的加锁规则不同之处在于：
1. 唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。
2. 非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。
# update没加索引会锁全表
> innodb默认的隔离级别是可重复读，在这个隔离级别下，会出现幻读的现象，innodb引擎使用next-key锁来解决幻读，update的时候如果发生了全表扫描，会给整张表加上锁

举例,表结构，id是唯一主键：
|id|name|sorce|
|---|---|---|
|1|lin|50|
|5|ming|68|
|10|hong|86|
|15|fei|87|
![](https://img-blog.csdnimg.cn/d2326f98cbb34fc09ca4013703251501.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16)
> 事务 A 的 update 语句中 where 是等值查询，并且 id 是唯一索引，所以只会对 id = 1 这条记录加锁，因此，事务 B 的更新操作并不会阻塞。

* 在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了

![](https://img-blog.csdnimg.cn/img_convert/1aa886fe95e7bc791c296e2d342fa435.png)
事务 A的 update 语句中 where 条件没有索引列，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表
![](https://img-blog.csdnimg.cn/img_convert/63e055617720853f5b64c99576227c09.png)
* 那 update 语句的 where 带上索引就能避免全表记录加锁了吗？  
**并不是。**关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了**全表扫描**，就会对全表的记录加锁了
## 解决方法
**sql_safe_updates**

# mysql死锁怎么办
## 为什么导致死锁了
> 没有打开死锁检测的情况下会出现互相等待的情况，间隙锁不会互斥，但是插入锁是互斥的
> ![](https://img-blog.csdnimg.cn/img_convert/90c1e01d0345de639e3426cea0390e80.png)  
> **插入意向锁与间隙锁是冲突的**，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以**两个事务中 select ... for update 语句并不会相互影响**
**间隙锁本质**上是用于阻止其他事务在该间隙内插入新记录，而自身事务是允许在该间隙内插入数据的。也就是说间隙锁的应用场景包括**并发读取、并发更新、并发删除和并发插入**。

* 插入意向锁
> 每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，那 Insert 语句应该被阻塞，并生成一个插入意向锁。这里会导致死锁！！

### insert语句加行级锁
* 隐式锁
> 当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会跳过加锁环节，这种机制称为隐式锁。
> 隐式锁是 InnoDB 实现的一种延迟加锁机制，其特点是只有在可能发生冲突时才加锁，从而减少了锁的数量，提高了系统整体性能  
> 隐式锁就是在 Insert 过程中不加锁，只有在特殊情况下，才会将隐式锁转换为显示锁，这里我们列举两个场景

1. 记录之间有间隙锁

每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，那 Insert 语句应该被阻塞，并生成一个插入意向锁

2. 遇到唯一键冲突
* 如果**主键值**重复：  

当隔离级别为**读已提交**时，插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加 **S 型记录锁**。
当隔离级别是可重复读（默认隔离级别），插入新记录的事务会给已存在的主键值重复的聚簇索引记录添加 **S 型记录锁**。
* 如果唯一二级索引列重复：  

不论是哪个隔离级别，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录添加 S 型 next-key 锁。
对的，没错，即使是读已提交隔离级别也是加 next-key 锁，这是读已提交隔离级别中为数不多的给记录添加间隙锁的场景。因为如果不添加间隙锁的话，会让唯一二级索引中出现多条唯一二级索引列值相同的记录，这就违背了 UNIQUE 的约束。




## 如何避免死锁
> 1. 设置事务等待锁的超时时间。
> 2. 开启主动死锁检测。
