
# 索引

## 分类
### 物理存储
> 1. 聚集索引
> 2. 非聚集索引（二级索引）
### 数据结构
> 1. b+树
> 2. hash
> 3. 全文
### 字段特性
> 1. 普通索引
> 2. 唯一索引
> 3. 主键suoyin
> 4. 前缀索引
### 字段个数
> 1. 单列索引
> 2. 多列索引

## 数据结构
> mysql的innodb引擎支持b+树索引、全文索引。不支持hash索引，但是内部有一个自适应hash索引。  
>  在创建表事，innodb会选择主键索引：
>  1. 如果有主键就使用主键
>  2. 没有主键就选择一个不包含null值的列
>  3. 两者都没有就会创建一个隐式自增的id作为聚簇索引的索引列
> 其他索引都属于辅助索引，也称二级索引或非聚集索引。二级索引和主键索引默认使用的都是B+树
## B+树是怎么存储数据的
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/btree.drawio.png)
> B+树是多叉树，非叶子结点存储索引，叶子结点存储值。叶子结点存放的数据是按主键顺序存放的
> **B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次**

## 聚簇索引查找数据
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/btree.drawio.png)
## 非聚簇索引查找数据
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png)
## 回表
> 二级索引查找到对应数据的主键值，需要去聚集索引查询具体数据的话，这个过程叫**回表**  
## 索引覆盖
> 二级索引可以查找到需要的值，就叫索引覆盖

## innodb选择B+树这个数据结构，而不选择其他数据结构
### 二叉树
### b树
> 1. 在相同的磁盘 I/O 次数下，就能查询更多的节点(b树的非叶子结点需要存储数据)
> 2. B+Tree 叶子节点采用的是**双链表**连接，适合 MySQL 中常见的**基于范围的顺序查找**，而 B 树无法做到这一点
### hash
> hash适合等值查询，无法处理范围查询

## 物理存储
### 聚集
### 非聚集


## 字段特性
### 普通索引
### 唯一索引
> 唯一索引建立在 **UNIQUE 字段**上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是**允许有空值**
### 主键索引
> 主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值**不允许有空值**
### 前缀索引
> 前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上.是为了减少索引占的空间，提升查询效率

## 字段个数
### 单列索引
### 联合索引
> 通过将多个字段组合成一个索引，该索引就被称为联合索引.
> ![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png)
> 存在**最左匹配**原则，建立（a,b,c）这样一个联合索引相当于建立了a,ab,abc三个索引。
> 联合索引的最左匹配原则，在遇到范围查询（>、<、between、like 包括like '林%'这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引。原因是按照abc的方向主键才是有序的

## 索引下推
现在我们知道，对于联合索引（a, b），在执行 select * from table where a > 1 and b = 2 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？ 
> 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数  
> 总结下就是在二级索引可以多过滤一下，减少回表次数

## 区分度
> 区分度是某一列的不同值个数/总的列数   
> 建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。  

## 什么时候考虑使用索引
### 索引的缺点
> 占用物理空间、维护开销

### 什么时候使用索引
1. 字段有唯一性限制的
2. 经常使用where和group by和order by查询的

### 什么时候不使用索引
1. 区分度低
2. 表数据少
3. 不在where，group by，order by使用的

## 索引如何优化
### 大字符串前缀索引
### 索引覆盖
### 主键索引自增
> 不自增会导致页分裂
> 主键长度不要太长

### 索引最好设置为NOT null
1. 计算区分度不包含null值，会导致优化器在做索引选择的时候更加复杂
2. null没意义会占用物理空间

### 防止索引失效
* 当我们使用**左或者左右模糊匹配**的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；
* 当我们在查询条件中对索引列做了**计算、函数、类型转换操作**，这些情况下都会造成索引失效；
* 联合索引要能正确使用需要遵循**最左匹配**原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
* 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效

## 总结
![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png)
---
