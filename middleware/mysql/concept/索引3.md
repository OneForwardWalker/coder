# like的左模糊查询，索引一定会失效吗
题目 2 的数据库表特别之处在于，只有两个字段，一个是主键索引 id，另外一个是二级索引 name，数据库只有两列
![](https://img-blog.csdnimg.cn/img_convert/a80a15eb8cd65eec777908282e04be2a.png)
首先，这张表的字段没有「非索引」字段，所以 **select * 相当于 select id,name**，然后这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含「索引值+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是**覆盖索引**
> 为什么选择全扫描二级索引树，而不扫描聚簇索引树呢？
因为二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列
# count(*) count(1)的效率对比

* 那种性能最好
![](https://img-blog.csdnimg.cn/img_convert/af711033aa3423330d3a4bc6baeb9532.png)
* count是什么
count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是**统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个**  
1. count(1) count(*) count(主键字段)
> 表里面有二级索引的话就会走二级索引（二级索引比聚集索引存储的东西少）
2. count(字段)
> 如果这个字段是普通字段的话，会采用全表扫描的方式，如果是统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引

* 如果大表需要经常使用count(*)

1. 维护个数
2. explain可以获得近似值
