# 最左匹配：
        首先使用第一列索引，然后使用第二列索引，建立一个A,B，C列的索引，实际上是A, AB，ABC三个索引
    
# 索引失效：
        2.1  单列索引，使用or，nnodb引擎索引失效，myisam的话，字段都有索引的情况下走索引
        2.2  多列索引，没有使用第一个字段，不会使用索引，遵循最左前缀原则
        2.3  like 以%开头
        2.4  查询条件列有隐式类型转换（列类型为字符串确使用数字的）或者调用mysql内置函数的导致索引失效（8.0以上有函数索引）或者使用列运算
        2.5  Mysql估计使用全表扫描比索引快的，不使用索引，查询的数量是大表的30%以上，或者是对小表查询的
        2.6  索引字段使用is null或者is not null的，可能会导致索引失效
        2.7 索引字段使用！=或者<>或者not in ,not exist时会导致索引失效
# innodb引擎和myIsam的区别：
        3.1 innoDB支持事务，2不支持
        3.2 1支持行锁和表锁，2只支持表锁
        3.3 1支持外键，2不支持
        3.4 1必须有主键，2不强制
        3.5 select count(*)，1需要全表扫描，2直接读取
# 慢查询解决：
    4.1 
# 索引
    是什么：
        5.1 一种提高查询效率的数据结构
        5.2 存储在磁盘中
        5.3  过多的索引影响插入更新性能
    类型：
        数据结构维度：
            Hash：适合等值查询
            b+树：数据存储在叶子结点，适合范围查询
            全文索引(B+树)：
        物理存储维度：
            聚集索引：以主键创建的索引，叶子结点存储的是表中的数据
            非聚集索引：以非主键创建的索引，在叶子结点存储的是主键和索引列，
        逻辑维度：
            主键索引：特殊的唯一索引，不允许有空值
            普通索引：基本索引类型，允许空值和重复值
            联合索引（多列索引）：多个字段创建的索引，使用时醉熏最左前缀原则
            唯一索引：索引列中的值唯一，可以为null
            空间索引
    为什么使用B+树作为数据库索引：
        为什么不用hash: hash只适合等值查询，对于范围查询无能为力
        为什么不用二叉树：二叉树会退化为链表
        为什么不用平衡二叉树：
            树的高度一般比较高
            查询更新需要旋转维持平衡，维护代价大
        为什么不用B树：
            使用了B树的升级版，b+树,区别
                B+树的非叶子结点不存储数据，只存储键值，B树的节点不仅存储键值还存储数据。innoDB默认页的大小为16kb,不存储数据就可以存储更多的键值，树的阶数就可以更大，树可以更矮胖，可以减少IO次数
                B+树的数据存储在叶子结点，按照顺序排序，并且有双向链表，使得支持范围查找，排序查找以及去重变得很简单
    使用非聚集索引查询要经历几次树的搜索操作：
        会经历两次树的搜索操作，第一次搜索非聚集索引找到存储ID，然后回表，查询聚集索引找到数据块读出数据
    覆盖索引：
        查询的数据列，在索引里面都有的话，就叫覆盖索引，就可以不回表，直接从索引拿到数据
    索引下推优化：
        在索引遍历的过程中直接过滤掉不满足条件的记录，减少回表的次数
    如何给千万级别的表加索引：
        加索引会对表加锁，操作不慎会导致生产事故
            1.先创建一个表结构和原表相同的表
            2.添加索引
            3.导入原表数据
            4.重命名表
# order by执行流程
    用到了sort buffer去做归并排序
# group by:
    ??
# 主从：
    主从复制的过程：
        1.主库的更新sql写到binlog
        2.从库发起连接，连接到主库
        3.主库创建binlog dump thread，把binlog的内容发送到从库
        4.从库启动后，创建一个IO线程，读取主库传过来的bin log内容写入relay log
        5.从库创建一个SQL线程，从relay log里面读取内容，将更新内容写入从DB
    怎么保证主从一致：
        长链接：主从之前维护一个长链接
        binlog格式：row格式保证一致但占空间大，statement模式占空间小但会导致不一致；采用mixed模式，由mysql决定使用那个格式
    那些情况会导致主从延迟：
        1.网络延迟大
        2.从库性能不好
        3.大事务
    高可用方案：
        1.主备
        2.一主一从
        3.一主多从
# 乐观锁和悲观锁：
    乐观锁一般会使用版本号机制或CAS算法实现。
    select ...for update就是悲观锁一种实现。
# binlog日志：
    归档日志，属于mysql server的日志，可以实现主从复制和数据恢复
    日志类型：statement， row（定义要删除的主键信息）， mixed
# 数据库事务
    四大特性：
        （1）原子性（Atomicity）原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。
        （2）一致性（Consistency）一个事务执行之前和执行之后都必须处于一致性状态。
        （3）隔离性（Isolation）隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
        （4）持久性（Durability）持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。
    隔离级别
        1）Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。
        2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
        3）Read committed (读已提交)：可避免脏读的发生。
        4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
# `数据库查询比较慢有哪些思路`  
## 查询的流程 客户端->server层->引擎层
    1. 客户端与server层建立连接
    2. server层分析器分析sql语法是否oK,优化器优化sql，执行器将优化后的sql发送到引擎层
    3. 引擎层执行指令
## 排查流程
    1. 索引
       1. 是否加了索引
       2. 索引的区分度怎么样
       3. 查询有没有用到索引，explain
    2. 连接数过小，客户端或者服务端连接数过少
       1. 获取不到连接的客户端需要阻塞
    3. buffer pool过小
       1. buffer pool过小会导致读磁盘，速度变慢
       2. show global variables like 'innodb_buffer_pool_size'; 通过查看buffer pool的命中率，看一下要不要调大buffer pool
    4. 是否可以使用查询缓存（只适用于读多写少的场景）




        
